import os, hashlib, pickle

from settings import *

DALVIK_BYTECODE = ['nop', 'move', 'move/from16', 'move/16', 'move-wide',
            'move-wide/from16', 'move-wide/16', 'move-object', 'move-object/from16', 'move-object/16',
            'move-result', 'move-result-wide', 'move-result-object', 'move-exception', 'return-void',
            'return','return-wide','return-object', 'const/4', 'const/16',
            'const', 'const/high16', 'const-wide/16', 'const-wide/32', 'const-wide',
            'const-wide/high16', 'const-string', 'const-string/jumbo', 'const-class', 'monitor-enter',
            'monitor-exit', 'check-cast', 'instance-of', 'array-length', 'new-instance',
            'new-array', 'filled-new-array', 'filled-new-array/range', 'fill-array-data', 'throw',
            'goto', 'goto/16', 'goto/32', 'packed-switch', 'sparse-switch',
            'cmpl-float', 'cmpg-float', 'cmpl-double', 'cmpg-double', 'cmp-long',
            'if-eq', 'if-ne', 'if-lt', 'if-ge', 'if-gt',
            'if-le', 'if-eqz', 'if-nez', 'if-ltz', 'if-gez',
            'if-gtz', 'if-lez', 'unused_3E', 'unused_3F', 'unused_40',
            'unused_41', 'unused_42', 'unused_43', 'aget', 'aget-wide',
            'aget-object', 'aget-boolean', 'aget-byte', 'aget-char', 'aget-short',
            'aput', 'aput-wide', 'aput-object', 'aput-boolean', 'aput-byte',
            'aput-char', 'aput-short', 'iget', 'iget-wide', 'iget-object',
            'iget-boolean', 'iget-byte', 'iget-char', 'iget-short', 'iput',
            'iput-wide', 'iput-object', 'iput-boolean', 'iput-byte', 'iput-char',
            'iput-short', 'sget', 'sget-wide', 'sget-object', 'sget-boolean',
            'sget-byte', 'sget-char', 'sget-short', 'sput', 'sput-wide',
            'sput-object', 'sput-boolean', 'sput-byte', 'sput-char', 'sput-short',
            'invoke-virtual', 'invoke-super', 'invoke-direct', 'invoke-static', 'invoke-interface',
            'unused_73', 'invoke-virtual/range', 'invoke-super/range', 'invoke-direct/range', 'invoke-static/range',
            'invoke-interface/range', 'unused_79', 'unused_7A', 'neg-int', 'not-int',
            'neg-long', 'not-long', 'neg-float', 'neg-double', 'int-to-long',
            'int-to-float', 'int-to-double', 'long-to-int', 'long-to-float', 'long-to-double',
            'float-to-int', 'float-to-long', 'float-to-double', 'double-to-int', 'double-to-long',
            'double-to-float', 'int-to-byte', 'int-to-char', 'int-to-short', 'add-int',
            'sub-int', 'mul-int', 'div-int', 'rem-int', 'and-int', 'or-int',
            'xor-int', 'shl-int', 'shr-int', 'ushr-int', 'add-long',
            'sub-long', 'mul-long', 'div-long', 'rem-long', 'and-long',
            'or-long', 'xor-long', 'shl-long', 'shr-long', 'ushr-long',
            'add-float', 'sub-float', 'mul-float', 'div-float', 'rem-float',
            'add-double', 'sub-double', 'mul-double', 'div-double', 'rem-double',
            'add-int/2addr', 'sub-int/2addr', 'mul-int/2addr', 'div-int/2addr', 'rem-int/2addr',
            'and-int/2addr', 'or-int/2addr', 'xor-int/2addr', 'shl-int/2addr', 'shr-int/2addr',
            'ushr-int/2addr', 'add-long/2addr', 'sub-long/2addr', 'mul-long/2addr', 'div-long/2addr',
            'rem-long/2addr', 'and-long/2addr', 'or-long/2addr', 'xor-long/2addr', 'shl-long/2addr',
            'shr-long/2addr', 'ushr-long/2addr', 'add-float/2addr', 'sub-float/2addr', 'mul-float/2addr',
            'div-float/2addr', 'rem-float/2addr', 'add-double/2addr', 'sub-double/2addr', 'mul-double/2addr',
            'div-double/2addr', 'rem-double/2addr', 'add-int/lit16', 'sub-int/lit16', 'mul-int/lit16',
            'div-int/lit16', 'rem-int/lit16', 'and-int/lit16', 'or-int/lit16', 'xor-int/lit16',
            'add-int/lit8', 'sub-int/lit8', 'mul-int/lit8', 'div-int/lit8', 'rem-int/lit8',
            'and-int/lit8', 'or-int/lit8', 'xor-int/lit8', 'shl-int/lit8', 'shr-int/lit8',
            'ushr-int/lit8', 'unused_E3', 'unused_E4', 'unused_E5', 'unused_E6',
            'unused_E7', 'unused_E8', 'unused_E9', 'unused_EA', 'unused_EB',
            'unused_EC', 'unused_ED', 'execute-inline', 'unused_EF', 'invoke-direct-empty',
            'unused_F1', 'iget-quick', 'iget-wide-quick', 'iget-object-quick', 'iput-quick',
            'iput-wide-quick', 'iput-object-quick', 'invoke-virtual-quick', 'invoke-virtual-quick/range', 'invoke-super-quick',
            'invoke-super-quick/range', 'unused_FC', 'unused_FD', 'unused_FE', 'unused_FF',
            ]

def create_decompile_path_list( root = DECOMPILE_PATH ) :
    ret_list = []
    subdirs = os.listdir(root)
    for dir in subdirs :
        if os.path.exists(os.path.join(root, dir, "smali")) :
            print(os.path.join(root, dir, "smali"))
            ret_list.append(os.path.join(root, dir, "smali"))
    return ret_list
	

def make_feature( root, DALVIK_BYTECODE_DICT ) :
    fh_list = [ 0 for i in range( (N_GRAM_END - N_GRAM_START + 1) * MAX_LIST_SIZE) ]
    feature_vector = []
    for path, dirs, files in os.walk(root) :
        for file in files :
            ext = os.path.splitext(file)[-1]
            if ext == '.smali' :
                elements = []
                try :
                    with open(os.path.join(path, file), 'r') as f :
                        for each in f.read().split() :
                            if each in DALVIK_BYTECODE_DICT :
                                elements.append(DALVIK_BYTECODE_DICT[each])
                except :
                    with open(os.path.join(path, file), 'r', encoding='utf-8') as f :
                        for each in f.read().split() :
                            if each in DALVIK_BYTECODE_DICT :
                                elements.append(DALVIK_BYTECODE_DICT[each])
                count_of_element = len(elements)
                if count_of_element < N_GRAM_END:
                    continue
                for n in range(N_GRAM_START, N_GRAM_END + 1):
                    gram_fh_list = [0 for i in range(MAX_LIST_SIZE)]
                    window = ''
                    for i in range(n):
                        window += elements[i]
                    hash_value = int(hashlib.sha256(window.encode('utf-8')).hexdigest(), 16)
                    index = hash_value & MOD_VALUE
                    gram_fh_list[index] += 1
                    for i in range(n, count_of_element):
                        window = window[len(elements[i - n]):] + elements[i]
                        hash_value = int(hashlib.sha256(window.encode('utf-8')).hexdigest(), 16)
                        index = hash_value & MOD_VALUE
                        gram_fh_list[index] += 1
                    max_value = max(gram_fh_list)
                    min_value = min(gram_fh_list)
                    for i in range(MAX_LIST_SIZE * (n - N_GRAM_START), MAX_LIST_SIZE * (n - N_GRAM_START) + MAX_LIST_SIZE) :
                        fh_list[i] += gram_fh_list[i - MAX_LIST_SIZE * (n - N_GRAM_START)]
    for n in range(N_GRAM_START, N_GRAM_END + 1) :
        temp = fh_list[MAX_LIST_SIZE * (n - N_GRAM_START) : MAX_LIST_SIZE * (n - N_GRAM_START) + MAX_LIST_SIZE]
        max_value = max(temp)
        min_value = min(temp)
        if max_value - min_value == 0 :
            feature_vector += [0 for i in range(MAX_LIST_SIZE)]
        else :
            feature_vector += [(x - min_value) / (max_value - min_value) for x in temp]

    md5 = root.split(os.sep)[-2]
    with open(os.path.join(FEATURE_VECTOR_PATH, md5 + '.fh'), 'wb') as f :
        pickle.dump(feature_vector, f)
    print(md5, 'is done')


def init() :
    ret_dict = {}
    for i, op in enumerate(DALVIK_BYTECODE) :
        ret_dict[op] = "%02x" %i
    return ret_dict

def run() :
    dir_list = create_decompile_path_list()
    DALVIK_BYTECODE_DICT = init()
    for dir_path in dir_list :
        make_feature(dir_path, DALVIK_BYTECODE_DICT)

if __name__ == '__main__' :
    run()
